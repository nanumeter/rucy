{"version":3,"sources":["../src/shame.js"],"names":["shamefullyClearAxisTypes","graphDiv","traceIndexes","update","Array","isArray","_fullData","hasSrc","key","substr","length","clearAxisTypes","axLetters","gd","traces","i","trace","j","type","ax","axAttr","_name","typeAttr","layout","set","shamefullyAdjustAxisRef","payload","tracesNeedingAxisAdjustment","forEach","axis","axisAttrToAdjust","charAt","currentAxisIdNumber","Number","slice","adjustedAxisIdNumber","currentAxisLayoutProperties","data","index","shamefullyAdjustGeo","geo","scope","shamefullyAddTableColumns","header","valuessrc","cells"],"mappings":"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","file":"shame.js","sourcesContent":["/*\n * DELETE THIS FILE. EVERYTHING NEEDS TO FIND A HOME.\n */\nimport {getFromId} from 'plotly.js/src/plots/cartesian/axis_ids';\nimport nestedProperty from 'plotly.js/src/lib/nested_property';\n\n// Temporary fix for:\n// https://github.com/plotly/react-chart-editor/issues/103\n// We should be able to remove this once the plotly.react method has\n// been integrated into react-plotly.js and released:\n// https://github.com/plotly/react-plotly.js/issues/2\nexport const shamefullyClearAxisTypes = (graphDiv, {traceIndexes, update}) => {\n  if (!Array.isArray(graphDiv._fullData)) {\n    return;\n  }\n  let hasSrc = false;\n  for (const key in update) {\n    if (key.substr(key.length - 3) === 'src') {\n      hasSrc = true;\n    }\n  }\n  if (hasSrc) {\n    clearAxisTypes(graphDiv, traceIndexes);\n  }\n};\n\nconst axLetters = ['x', 'y', 'z'];\nfunction clearAxisTypes(gd, traces) {\n  for (let i = 0; i < traces.length; i++) {\n    const trace = gd._fullData[i];\n    for (let j = 0; j < 3; j++) {\n      const type = axLetters[j];\n      const ax = getFromId(gd, trace[type + 'axis'] || type);\n\n      // Do not clear log type.\n      // Log type is never an auto result so must have been intentional.\n      // We are also skipping clearing 3D which could cause bugs with 3D.\n      if (ax && ax.type !== 'log') {\n        const axAttr = ax._name;\n        const typeAttr = axAttr + '.type';\n        nestedProperty(gd.layout, typeAttr).set(null);\n      }\n    }\n  }\n}\n\nexport const shamefullyAdjustAxisRef = (graphDiv, payload) => {\n  if (payload.tracesNeedingAxisAdjustment) {\n    payload.tracesNeedingAxisAdjustment.forEach(trace => {\n      const axis = trace[payload.axisAttrToAdjust].charAt(0);\n      const currentAxisIdNumber = Number(\n        trace[payload.axisAttrToAdjust].slice(1)\n      );\n      const adjustedAxisIdNumber = currentAxisIdNumber - 1;\n\n      const currentAxisLayoutProperties = {\n        ...graphDiv.layout[payload.axisAttrToAdjust + currentAxisIdNumber],\n      };\n\n      // for cases when we're adjusting x2 => x, so that it becomes x not x1\n      graphDiv.data[trace.index][payload.axisAttrToAdjust] =\n        adjustedAxisIdNumber === 1 ? axis : axis + adjustedAxisIdNumber;\n\n      graphDiv.layout[\n        payload.axisAttrToAdjust + adjustedAxisIdNumber\n      ] = currentAxisLayoutProperties;\n    });\n  }\n};\n\nexport const shamefullyAdjustGeo = ({layout: {geo = {}}}, {update}) => {\n  if (update['geo.scope']) {\n    update['geo.projection'] = {};\n    update['geo.center'] = {};\n  }\n  if (\n    // requesting projection change\n    update['geo.projection.type'] &&\n    (update['geo.projection.type'] === 'albers usa' || geo.scope === 'usa')\n  ) {\n    update['geo.scope'] = {};\n    update['geo.center'] = {};\n  }\n};\n\nexport const shamefullyAddTableColumns = (graphDiv, {traceIndexes, update}) => {\n  if (\n    update['cells.values'] &&\n    (!graphDiv.data[traceIndexes[0]].header ||\n      !graphDiv.data[traceIndexes[0]].header.valuessrc)\n  ) {\n    update['header.values'] = update['cells.valuessrc'];\n  } else if (update['header.values'] === null) {\n    update['header.values'] =\n      graphDiv.data[traceIndexes[0]].cells.valuessrc || null;\n  } else if (\n    update['cells.values'] === null &&\n    !graphDiv.data[traceIndexes[0]].header.valuessrc\n  ) {\n    update['header.values'] = null;\n  }\n};\n"]}