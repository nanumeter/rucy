'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shamefullyAddTableColumns = exports.shamefullyAdjustGeo = exports.shamefullyAdjustAxisRef = exports.shamefullyClearAxisTypes = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*
                                                                                                                                                                                                                                                                   * DELETE THIS FILE. EVERYTHING NEEDS TO FIND A HOME.
                                                                                                                                                                                                                                                                   */


var _axis_ids = require('plotly.js/src/plots/cartesian/axis_ids');

var _nested_property = require('plotly.js/src/lib/nested_property');

var _nested_property2 = _interopRequireDefault(_nested_property);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Temporary fix for:
// https://github.com/plotly/react-chart-editor/issues/103
// We should be able to remove this once the plotly.react method has
// been integrated into react-plotly.js and released:
// https://github.com/plotly/react-plotly.js/issues/2
var shamefullyClearAxisTypes = exports.shamefullyClearAxisTypes = function shamefullyClearAxisTypes(graphDiv, _ref) {
  var traceIndexes = _ref.traceIndexes,
      update = _ref.update;

  if (!Array.isArray(graphDiv._fullData)) {
    return;
  }
  var hasSrc = false;
  for (var key in update) {
    if (key.substr(key.length - 3) === 'src') {
      hasSrc = true;
    }
  }
  if (hasSrc) {
    clearAxisTypes(graphDiv, traceIndexes);
  }
};

var axLetters = ['x', 'y', 'z'];
function clearAxisTypes(gd, traces) {
  for (var i = 0; i < traces.length; i++) {
    var trace = gd._fullData[i];
    for (var j = 0; j < 3; j++) {
      var type = axLetters[j];
      var ax = (0, _axis_ids.getFromId)(gd, trace[type + 'axis'] || type);

      // Do not clear log type.
      // Log type is never an auto result so must have been intentional.
      // We are also skipping clearing 3D which could cause bugs with 3D.
      if (ax && ax.type !== 'log') {
        var axAttr = ax._name;
        var typeAttr = axAttr + '.type';
        (0, _nested_property2.default)(gd.layout, typeAttr).set(null);
      }
    }
  }
}

var shamefullyAdjustAxisRef = exports.shamefullyAdjustAxisRef = function shamefullyAdjustAxisRef(graphDiv, payload) {
  if (payload.tracesNeedingAxisAdjustment) {
    payload.tracesNeedingAxisAdjustment.forEach(function (trace) {
      var axis = trace[payload.axisAttrToAdjust].charAt(0);
      var currentAxisIdNumber = Number(trace[payload.axisAttrToAdjust].slice(1));
      var adjustedAxisIdNumber = currentAxisIdNumber - 1;

      var currentAxisLayoutProperties = _extends({}, graphDiv.layout[payload.axisAttrToAdjust + currentAxisIdNumber]);

      // for cases when we're adjusting x2 => x, so that it becomes x not x1
      graphDiv.data[trace.index][payload.axisAttrToAdjust] = adjustedAxisIdNumber === 1 ? axis : axis + adjustedAxisIdNumber;

      graphDiv.layout[payload.axisAttrToAdjust + adjustedAxisIdNumber] = currentAxisLayoutProperties;
    });
  }
};

var shamefullyAdjustGeo = exports.shamefullyAdjustGeo = function shamefullyAdjustGeo(_ref2, _ref3) {
  var _ref2$layout$geo = _ref2.layout.geo,
      geo = _ref2$layout$geo === undefined ? {} : _ref2$layout$geo;
  var update = _ref3.update;

  if (update['geo.scope']) {
    update['geo.projection'] = {};
    update['geo.center'] = {};
  }
  if (
  // requesting projection change
  update['geo.projection.type'] && (update['geo.projection.type'] === 'albers usa' || geo.scope === 'usa')) {
    update['geo.scope'] = {};
    update['geo.center'] = {};
  }
};

var shamefullyAddTableColumns = exports.shamefullyAddTableColumns = function shamefullyAddTableColumns(graphDiv, _ref4) {
  var traceIndexes = _ref4.traceIndexes,
      update = _ref4.update;

  if (update['cells.values'] && (!graphDiv.data[traceIndexes[0]].header || !graphDiv.data[traceIndexes[0]].header.valuessrc)) {
    update['header.values'] = update['cells.valuessrc'];
  } else if (update['header.values'] === null) {
    update['header.values'] = graphDiv.data[traceIndexes[0]].cells.valuessrc || null;
  } else if (update['cells.values'] === null && !graphDiv.data[traceIndexes[0]].header.valuessrc) {
    update['header.values'] = null;
  }
};
//# sourceMappingURL=shame.js.map